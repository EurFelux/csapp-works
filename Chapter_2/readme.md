# Homework of Chapter 2

未能自力解决的问题：

- [x] 2.65
- [x] 2.66
- [x] 2.71 (题目描述问题)
- [x] 2.79 (翻译导致的题目理解有误)
- [x] 2.80 (翻译导致的题目理解有误)
- [x] 2.85 C

## 第一部分

### 2.55

从运行结果来看，我的机器是使用小端法的机器。

### 2.56

已经这样做了。

### 2.57

写是写出来了。但我哪来的几种机器啊？别难为我了吧。

### 2.58

`2.58.cpp`

### 2.59

`2.59.cpp`

### 2.60

`2.60.cpp`

## 第二部分

这里开始要应用以下规则：

- 假设
  - 整数用补码表示
  - 有符号数使用算术右移
  - 数据类型 int 有 $\omega$ 位，可以使用`sizeof(int) << 3`来计算$\omega$
- 禁止使用
  - 条件语句（`if`, `?:`）、循环、分支语句、函数调用、宏调用
  - 除法、模运算、乘法
  - 相对比较运算（`>`、`<`、`>=`、`<=`）
- 可以使用
  - 逻辑运算、位运算
  - 左移和右移，但是位移量在 0 和 w-1 之间
  - 加法、减法
  - `==` 和 `!=`
  - 常数 `INT_MIN` 和 `INT_MAX`
  - 对 `int` 和 `unsigned` 进行强制类型转换，无论是显式的还是隐式的

### 2.61

`2.61.cpp`

### 2.62

`2.62.cpp`

所以说测不了啊！！

### 2.63

`2.63.cpp`

#### `srl`的实现

因为逻辑右移无论如何只会补充0，所以只要把高k位清零就行了。目标是创建一个高k位全为0，低w-k位全为1的数，然后与x做与运算。但是`k == 0`的情况下，`w - k`会变成`w`，所以要特殊处理。

哦这简直是天才般的发想！`~(!!k) + 1`，还有异或操作！

#### `sra`的实现

只要判断出符号，然后把高k位补上符号位就行了。目标是创建一个高k位全为1，低w-k位全为0的数，然后如果x是负数，就与这个数做或运算，否则与0做或运算。然而这里不能再用右移了，怎么判断符号呢？

龟龟，完美的投球，马内！这表达式看得我自己都头晕！

### 2.64

`2.64.cpp`

### 2.65

`2.65.cpp`

~~不会啊！~~

这个过程要我自己想出来恐怕是有点难为我了。

```cpp
int odd_ones(unsigned x)
{
   x ^= (x >> 1);
   x ^= (x >> 2);
   x ^= (x >> 4);
   x ^= (x >> 8);
   x ^= (x >> 16);
   return x & 1;
}
```

这是32位的实现。我解释一下这个算法：

1. `x ^= (x >> 1)`，这使得在更新后的`x`的第1, 3, 5, ..., 31位上存储了`x`的相邻位的`1`的个数的奇偶情况。如果相邻位是`00`或者`11`，那么这些位上的值就是`0`，否则就是`1`。`0`表示相邻2位上没有奇数个`1`，`1`表示有奇数个`1`。
2. `x ^= (x >> 2)`，这使得在更新后的`x`的第1, 5, 9, ..., 29位上存储了`x`的相邻4位的`1`的个数的奇偶情况。`0`表示相邻4位上没有奇数个`1`，`1`表示有奇数个`1`。
3. 以此类推，最终在`x ^= (x >> 16)`以后，`x`的第1位上存储了`x`的所有位的`1`的个数的奇偶情况。`0`表示`x`的所有位上没有奇数个`1`，`1`表示有奇数个`1`。
4. 此时只需要`x & 1`，就能得到`x`的所有位上`1`的个数的奇偶情况。

总计用了11个运算，符合题目要求。

### 2.66

`2.66.cpp`

~~也不会啊！~~

2.65中使用`^`来判断奇数个`1`的个数，这里使用类似的方法，但是换成`|`，实现的效果是将最左侧的1扩展到低位。

### 2.67

A. C语言标准不保证`int`有32位表示。对于16位机器而言，这是未定义行为。另外，`<< 32` 也是未定义行为。编译器在实现上可能会取模使得结果相当于`<< 0`，但对C语言标准而言，这是未定义行为。

B. `2.67.cpp` 

C. `2.67.cpp`

### 2.68

`2.68.cpp`

很遗憾，我在2.63里已经把这个问题解决了。

### 2.69

`2.69.cpp`

果然我已经在2.63解决了很核心的问题。没有白思考三个小时啊。啊哈哈~

### 2.70

`2.70.cpp`

对于一个w位补码表示的非负数而言，判断其是否能够由n位补码表示，只要判断从它是否从第n位开始到最高位全为0即可。所以只要构造一个n位全为1的数，然后与x做与运算，看结果是否为0即可。

对于一个w位补码表示的负数，则要判断它是否从第n位开始到最高位全为1。所以只要构造一个n位全为0的数，然后与x做或运算，看结果是否为全1即可。

哎呀，这个问题我在2.63里也解决了啊！说到底最核心的就是掩码问题，而掩码问题在2.63里已经解决了。

### 2.71

A. 问题在于，字节是有符号字节，而抽出的时候没有处理符号。例如，如果抽出的字节是`0xFF`，那么它实际上是-1，而不是255。

B. `2.71.cpp`.

只允许使用移位和一次减法，这怎么解决呢？这真的是1级难度吗？要是能用强制类型转换就好了。

查询了网络上的实现，大都使用了强制类型转换来实现，而不用强制类型转换的代码都无法通过测试。我认为这是题目的问题。不用强制类型转换恐怕真的无法实现。

### 2.72

A. 发生无符号数的下溢出。拜托……为什么总是喜欢用减法呢？

B. `2.72.cpp` 把条件改改就好了

### 2.73

positive overflow: `x > 0 && y > 0 && x + y <= 0`,
negative overflow: `x < 0 && y < 0 && x + y >= 0`,
也就是说，`x`和`y`为正，同时`x + y`不为正；或者`x`和`y`为负，同时`x + y`不为负。

感觉对位运算的理解加深了。

### 2.74

练习题2.32. `2.74.cpp`
姑且遵守了规则，虽然题面本身没有要求的样子。拿2.73改改就能用了。

### 2.75

如果我没记错的话，有符号乘积和无符号乘积的位模式是相同的。
比起这个，我上哪找`signed_high_prod`这库函数去？
就假设能用吧。无符号和有符号，其乘积的位表示都是相同的。所以如果想要得到无符号的乘积高位，只要直接把有符号的乘积高位强制转换成无符号的就行了。位模式不会发生变化，因此结果是正确的。

但这样做的话，我的工作在哪？只是知道这点而已吗？

### 2.76

练习2.35很有价值，大概是这样的。

### 2.77

A. `(x << 4) + x`

B. `x - (x << 3)`

C. `(x << 6) - (x << 2)`

D. `(x << 4) - (x << 7)`

### 2.78

我还真的把向上取整时的表达式给忘了。

### 2.79

~~给出了乘法必定会溢出的前提。但是，先计算`/4`的话又会有误差。~~

我服了这个中译版。原版写的是我应该复现计算`3*x`会溢出时的行为，而不是给出`3*x`不溢出再`/4`的结果。我真服了这中译版。

`3*x`直接使用移位实现，除法复用2.78的代码。

### 2.80

~~和2.79的区别是什么呢……~~

怪不得我会产生这种疑问。都是翻译的问题啊。

这里原文是：

> *It should not overflow.*

而译文则是：

> *它不会溢出。*

原文的意思应该是设计一个不受溢出影响，计算出正确结果的函数。而译文看起来就像是提供了一个乘法不会溢出的假设一样！真烂啊这翻译。

这里只是`*3`，溢出最多溢出两位。如果我先`/4`再`*3`，就不会发生溢出了。然而，这样将会产生舍入误差。问题的核心在于，有多少值在做除法的时候被舍入了？可能的值是1/4, 2/4, 3/4，而这个误差会乘以三倍，即3/4, 6/4, 9/4。

$$
res = x/4 * 3 + e
$$

$$
e = 
\begin{cases}
2, & \text{if } x \mod 4 = 3 \\
1, & \text{if } x \mod 4 = 2 \\
0, & \text{else} \\
\end{cases}
$$

这里$e$是舍入后的结果。所以，只要知道$x$的最低两位是什么，就能知道$e$的值。

### 2.81

```cpp
unsigned bit_pattern_A(unsigned k) {
    // mask = 0xFF...FF if k == 0; otherwise mask = 0.
    unsigned mask = (~!!(k ^ 0) + 1);

    // to avoid k == w
    return ~0 << ((k - 1) & mask) << (1 & mask) << (k & ~mask);
}

unsigned bit_pattern_B(unsigned j, unsigned k) {
    unsigned mask_k = (~!!(k ^ 0) + 1);
    unsigned mask_j = (~!!(j ^ 0) + 1); 
    return ~(~0 << ((k - 1) & mask_k) << (1 & mask_k) << (k & ~mask_k))
            << ((j - 1) & mask_j) << (1 & mask_j) << (j & ~mask_j);
}
```

### 2.82

A. 在`x`或`y`仅其一为`INT_MIN`时，表达式为`false`

B. 即使发生溢出，低32位的位模式仍是相等的。所以这个表达式应该恒为1

C. 因为`~x+1 == -x`，所以两边总是相等的，表达式恒为1

D. 无论如何溢出和转换，两边的位模式都是相同的，表达式恒为1

E. `x == 5`时，表达式为`false`。右移可能产生舍入。

### 2.83

A. $ x = \sum^{\infty}_{n=1}Y2^{-kn} $

B. 怎么，这要我给算一遍？

  a. 0.7142857142857142

  b. 0.4

  c. 0.30158730158730157

### 2.84

浮点数还是来了啊。

浮点数规格：$V = (-1)^s\times M\times 2^E$.

考虑到对于浮点数而言，只要比较除去符号位的位模式大小就能确定绝对值的大小，所以……这个问题就很简单了。

```cpp
return (sx > sy) || 
       (!(sy > sx) && 
        (((ux << 1) <= (uy << 1) && !sx) || 
         ((ux << 1) >= (uy << 1) && sx)));
```

已在`2.84.cpp`通过测试。

### 2.85

#### A

规格化数表示：

- $V = 7.0 = 111_2 = (-1)^{0}\times 1.11_2\times 2^{2}$
- $E = 2$, $e = 2 + bias$
- $M = 1_2 + f$
- $f = 0.11_2$
- 位表示：`0 10000001 11000000000000000000000`（假设是32位浮点数）

#### B

即，用二进制表示后，该数的最低位为1，而且刚好需要用(n+1)位表示，而且应当是一个正数。这个数应该从最低位到第n+1位全为1，而其他位全为0。

那么，这个数的规格化表示为：

- $V = 1.111\dots_2\times 2^{n}$
- $E = n = e - bias$
- $M = 1_2 + f$
- $f = 0.111\dots_2$
- 位表示：`0 10010110 11111111111111111111111`（假设是32位浮点数）

#### C

我哪会什么浮点数除法啊……但是最小规格化数可以描述一下。其小数部分全为1，而指数部分为`111...110`，符号位为`1`。这是正负意义上的最小。绝对值最小则是指数部分为`000...001`，小数部分为`000...000`。

啊！这里不需要浮点数除法。是这样的：

$$
V = (-1)^n\times 1.0\times 2^{1-bias}
$$

因为$M=1.0$，所以求倒数只要处理指数部分就可以了。$E' = bias - 1$，$e' = E' + bias$，其位模式是：`0 11111101 00000000000000000000000`。

### 2.86

| 描述 | 值 | 十进制 |
| --- | --- | --- |
| 最小的正非规格化数 | `0 00...00 0 00...01` | $2^{-63}$ |
| 最小的正规格化数 | `0 00...01 1 00...00` | $1 + 2^{-16382}$ |
| 最大的规格化数 | `0 11...10 1 11...11` | $2^{16383}(2 - 2^{-63})$ |

我不明白这哪里有趣了？

### 2.87

好的这次我们来研究fp16。

| 描述 | Hex | M | E | V | D |
| --- | --- | --- | --- | --- | --- |
| -0 | 8000 | 0 | -14 | -0 | -0.0 |
| 最小的>2的值| 4001 | $\cfrac{1025}{1024}$ | 1 | $1025\times 2^{-9}$ | 2.001953 |
| 512 | 6000 | 0 | 9 | 512 | 512.0 |
| 最大的非规格化数 | 03FF | $\cfrac{1023}{1024}$ | -14 | $1024\times 2^{-10}$ | 0.999023 |
| $-\infty$ | FC00 | — | — | $-\infty$ | $-\infty$ |
| 0x3BB0 | $\cfrac{123}{64}$ | -1 | $123\times 10^{-7}$ | 0.960938 |

D 列是用`2.87.cpp`输出的。

### 2.88

| 位 | 值 | 位 | 值 |
| --- | --- | --- | --- |
| 1 01110 001 | -9/16 | 1 0110 0010 | -9/16 |
| 0 10110 101 | 208 | 0 1110 1010 | 208 |
| 1 00111 110 | $-7/2^{10}$ | 1 0000 0000 | -0 |
| 0 00000 101 | $5/2^{17}$ | 0 0000 0001 | $1/2^{10}$ |
| 1 11011 000 | $-2^{12}$ | 1 1110 1111 | -248 |
| 0 11000 100 | $3\times 2^8$ | 0 1110 1111 | 248 |

没有舍入到无穷大，这样符合要求吗？

### 2.89

A. 当`x`转换为`float`产生舍入误差时，`dx`再转换为`float`时，理论上会产生相同的舍入误差。这个表达式应该是恒为真的。

B. `dx-dy`不会下溢出，但是`x-y`会，给出这个反例：`x = INT_MIN, y = 1`。

C. 尽管浮点运算没有结合性，但是`double`类型能够精确表示`int`的所有值，也能够精确表示两个`int`类型相加的所有值。所以这个表达式应该是恒为真的。

D. 尽管`double`能够精确表示两个`int`的和，却未必能精确表示两个`int`的积。给出反例：`x = 538923759, y = 583927495, z = 3`。（找这么个反例真不容易……）

E. `x`或者`z`为0时，除法结果得到`nan`。这样表达式就可能为假。

另外，可以分析一下`double`不能精确表示的最小正整数。这个数是`2^53 + 1`。很显然，这个数已经远远超过了`int`的表示范围。所以，`double`类型能够精确表示`int`的所有值，也能够精确表示两个`int`类型相加的所有值。

### 2.90

$2^x$的w位浮点表示。

从题面来看，假设`float`是32位。`int`至少也是16位，这里`int`的范围无所谓。

既然`float`是32位，那么其指数表示范围就是$2^{-126}$到$2^{127}$。这里是计算$2^x$，所以小数部分要么是全为0（规格化数），要么在某个位置有个1（非规格化数）。

非规格化数的情况下，$e = 0$, $M = f$, $V = (-1)^s\times f\times 2^{-126}$。$f$的部分最小是$2^{-23}$，所以$V$的最小值是$2^{-149}$。而最小的规格化数是$2^{-126}$，所以`else if (x < -126)`。接着，`exp = 0`是固定的。`frac`通过`x`计算，结果是`frac = 1 << (149 + x)`。

规格化数的情况下，$E = x <= 127$，所以`x < 128`。然后$V = (-1)^s\times (1+f)\times 2^{x}$。因为要计算的是$2^x$，所以`frac = 0`，即$V =2^{x}$。$e = E + bias = x + 127$，所以`exp = x + 127`。

返回无穷的情况就比较简单了。符号位确定为0，指数位全为1，小数位全为0。

### 2.91

#### A

0x40490FDB的位模式：`0 10000000 10010010000111111011011`。

从而，$M = 1.10010010000111111011011$，$E = 128 - 127 = 1$，$V = 1.10010010000111111011011_2\times 2 = 11.0010010000111111011011_2$。

#### B

我寻思这2.83也帮不上什么忙。还以为你给我$1/7$的表示了呢。

不过，经过一些实验，看来$1/7 = 0.[001]_2$。所以，$22/7$的二进制小数表示就是`11.[001]_2`。

#### C

比较这两者：

- `11.0010010000111111011011`
- `11.001001001001...`

可见，从第9位开始二者就不同了。

## 第三部分

规则：

- 遵循IEEE浮点运算规则，舍入使用向偶数舍入
- `typedef unsigned float_bits;`
- 不能使用`float`，而要使用`float_bits`
- 可以使用`int`和`unsigned`，无符号和整数常数以及运算
- 不能使用联合、结构、数组
- 不能使用浮点数据类型、运算、常数

连库函数都没BAN。

### 2.92

`2.92.cpp`。

总之就是很简单。对`nan`特别处理后，只要对符号位取补就行了。

### 2.93

`2.93.cpp`.

还是挺简单的。对`nan`特别处理，如果不是`nan`的话，就只要无脑把符号位变成0就行。

测试的时候，虽然尝试用`fabs()`去获得结果，但是`fabs()`返回的是一个有些特别的nan，而不是返回参数本身。因此不能简单地判断`u2f(res) != target`。可以使用`isnan`来判断。

### 2.94

`2.94.cpp`.

其实我是先做的2.95。这两道题看起来有一些共通之处。分析过程cp一下~

考虑 $V = (-1)^s\times M\times 2^E$，要实现 `* 2`这个运算的话，只要把`E`加一就行了。但是，如果`E`无法加一的话，就要处理`M`。
另外，如果是0或者无穷的话，也直接返回。

对于`e = 0b11111110`这种最大值的情况，`E`无法加一，也无法从`M`上下手。结果是超出了浮点数的表示范围，应该返回无穷。

对于`e=0`时候的情况，`E`是相同的，都是最小值，所以必须从`f`上着手。如果`f`的最高位是1，要给`M`乘二，就会变成规格化值。此时要变成`e=1`，`f`左移一位并清除掉23位以后的高位。如果`f`的最高位不是1，就直接给`f`左移一位就行了。

对于`e`是其它取值的情况，都可以简单地通过给`e`加一来实现。

### 2.95

考虑 $V = (-1)^s\times M\times 2^E$，要实现 `* 0.5`这个运算的话，只要把`E`减一就行了。但是，如果`E`无法减一的话，就要处理`M`。
另外，如果是0或者无穷的话，就直接返回。

对于`e = 1`和`e = 0`这两种情况，`E`是相同的，都是最小值，所以必须从`M`上着手。

`e = 1`时，要将`M = 1 + f`减半，必然需要变为`M=f`，也就是说还是需要`exp -= 1`。然而，区别在于这里还必须额外处理`f`。从规格化变为非规格化，意味着精度位少了一个。如果`f`的最低位是1，就会出现舍入误差。舍入应该向偶数舍入。

`e = 0`时同样，除了右移一位之外，还要考虑舍入问题。

有一种极端情况，即$e=1$, $V = (-1)^{s}\times 1.1111...111_2\times 2^{-126}$，这种时候为$f$右移一位需要向上舍入，但是整体会变成$V = (-1)^{s}\times 1.0000...000_2\times 2^{-126}$。这种情况下，仅仅是`frac`变为全0，而`exp`不变。

### 2.96

溢出的情况：因为`int`的范围在$[-2^{31},2^{31}-1]$，所以对于$E\geq 31$（非负数）和$E>31$（负数）的情况，都会发生溢出。$e = E - 127$，所以就是$e\geq 158$和$e>158$的情况。

特别处理$e = 158$的情况。当且仅当$f = 0$且$s = 1$时不发生溢出。

对于不会发生溢出的情况，先处理掉`INT_MIN`的可能性，然后就能确定$e < 158$。

另外，对于 $V < 1$的情况，可以直接返回0。这种情况下，$E < 0$，则$e < 127$。

现在，只需要处理$E\in [0,30]$，即$e\in [127, 157]$。再度考虑这个式子：

$$
V = (-1)^s\times (1+f)\times 2^E
$$

注意到$1+f$是一个二进制小数，我们可以通过右移23位将它转换为整数。实际操作的时候，只要为`frac`的第24位添加一个1即可获得其整数表示$I = (1+f)\times 2^{23}$，从而：

$$
V = (-1)^s\times I\times 2^{E-23}
$$

然而，问题在于$E-23$可能得到一个负数，这样就没法得到整数表示了。为了解决这个问题，考虑不是将$1+f$右移23位，而是右移$d=\min\set{23, E}$位。这种情况下，有$I = (1+f)\times 2^{d}$。这样，就有：

$$
V = (-1)^s\times I\times 2^{E-d}
$$

在$d = 23$的情况下，$E\geq d$, 从而$V = (-1)^s\times I\times 2^{E-d}$是一个整数。

在$d < 23$的情况下，$E=d$，从而$V = (-1)^s\times I$。这里$I$仍可能是一个小数。但是没关系，只要丢掉小数部分就是整数了。

代码操作上，将`frac`的第24位置为1，然后右移 $23-d$ 位，就能得到$I$。

### 2.97

粗略一看又要考虑舍入问题。

已知的事实是，`int`可以不溢出地转换为`float`，即不必考虑NaN和无穷的情况。但是，可能出现舍入误差，所以要考虑舍入问题。

考虑人工如何将一个`int`转为`float`。

1. 首先我们要确定`int`的符号，然后将其转为绝对值的无符号表示。然而如果直接`-x`的话，`INT_MIN`仍然是`INT_MIN`。不过如果使用`~x+1`的方式，即使是`INT_MIN`也能够获得正确的值。
2. 然后，对获得的无符号值，找到其最高位的1，这个1作为隐藏精度位。（这里有一个重要前提，就是除了0以外，所有`int`值的绝对值都是大于等于1的，因而不会是非规格数。所以，`0` 需要特别处理。）
3. 除去最高位的1以外，余下的低`k`位作为`frac`。同时有$E = k$，于是`exp = k + 127`。
   1. 然而，可能出现`k > 23`的情况，此时必须要舍入。舍入规则为向偶数舍入。记录下`frac`的低`k-23`位为`tail`，然后将`frac`右移`k-23`位。取`mask_round = 1 << (k-24)`，然后：

      - `tail < mask_round`，向下舍入，什么都不用做
      - `tail > mask_round`，向上舍入，`frac += 1`
      - `tail == mask_round`，考虑`frac`的最低位，如果是`1`，向上舍入，`frac += 1`，否则向下舍入，什么都不用做。

   2. 对于需要向上舍入的情况，还需要额外考虑`frac`的低23位全为`1`的极端情况。这种情况下，`frac`会变成`0`，`exp`需要加一。
   3. 如果`k<=23`就是最好的，不需要考虑舍入问题，`frac`就是最终结果。
4. 得到正确的`frac`和`exp`之后，根据最开始记录下的符号位，设置正确的符号位，组合好`exp`和`frac`，就得到了正确的结果。
